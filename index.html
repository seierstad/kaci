<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript phase distortion synthesis</title>
    <style>
    	#envelope,
    	#waveform
    	{
    		border: 1px dotted green;
    	}
    	body {
    		background: orange;
    	}
    	.controller {
    		border: 1px dotted yellow;
    		background: rgba(255,255,255,0.2);
    	}
    	#pd-plot {
    		border: 1px dotted blue;
    		background: rgba(255,255,255,0.1);
    	}
    	.key {
        	stroke: #000;
    	}
    	.black {
    		fill: #000;
    	}
    	.white {
    		fill: #fff;
    	}
    	.pressed {
    		fill: #afe;
    	}
    </style>
  </head>
  <body>
  	<canvas height="500" width="500" id="waveform"></canvas>
  	<br />
	<div id="container"></div>
    <input type="range" size="4" id="freq" value="110"><label for="hz">Hz</label>

	 <script type="text/javascript" src="ControlledValue.js"></script>

    <script type="text/javascript">
var kaci = {    
		resonantPhaseFactor: new ControlledValue(0.9),
		frequency: new ControlledValue(0),
		frequency.afterUpdate: function() {
			phase_increment = this.value / sampleRate;
		},
      currentSoundSample: 0,
      sampleRate: 44100,
      phase: 0,
      phase_increment: frequency.value / sampleRate,
      points: [[0, 0], [1, 1]],
      selectedPointIndex: null,

	  pointRadius: 10,
	  lineWidth: 1,

      waveformCanvas: document.getElementById("waveform"),
      waveform: waveformCanvas.getContext("2d"),

	  linearFunctionFromPoints: function (points) {
			var rate, constant;
			rate = (points[1][1] - points[0][1]) / (points[1][0] - points[0][0]);
			constant = points[0][1] - ( rate * points[0][0] );
			return {'rate': rate, 'constant': constant};
		},
      limitZeroToOne: function (input) {
			if (input > 1) {
				return 1;
			} else if (input < 0){
				return 0;
			} else {
				return input;
			}
      },
	  phaseDistort: function (inputPhase) {
			var phase = limit(inputPhase);
			if (pdData.value.length > 1) {
				var line;
				for (var i = 1; i < pdData.value.length; i++) {
					if (phase >= pdData.value[i-1][0] && phase < pdData.value[i][0]) {
						line = linearFunctionFromPoints([pdData.value[i-1], pdData.value[i]]);
						return limitZeroToOne((phase * line.rate) + line.constant);
					}
				}
			} 
		},
		limit: function (phase) {
			while (phase > 1) {
				phase -= 1;
			}
			while (phase < 0) {
				phase += 1;
			}
			return phase;
		},
		sinus: function (phase) {
			return Math.sin(phase * Math.PI * 2);
		},
		cosinus: function (phase) {
			return Math.cos(phase * Math.PI * 2);
		},
		
		square: function (phase) {
			var limitedPhase = limit(phase);
			if (limitedPhase > 0.5) {
				return 1;
			} else {
				return -1;
			}
		},
		anneMarie: function (phase) {
			var limitedPhase = limit(phase);
			if (limitedPhase < 0.5) {
				return limitedPhase * 2;
			} 
			if (limitedPhase >= 0.5) {
				return (limitedPhase-1) * 2;
			}
		},
		baseWaveforms: {
			'sinus' : sinus,
			'cosinus' : cosinus,
			'square' : square,
			'Anne-Marie' : anneMarie
		},
		constantWrapper: function (phase) {
			var constant = 1;
			return constant;
		},
		
		linearWrapper: function (phase) {
			return 1-phase;
		},
		
		halfSinusWrapper: function (phase) {
			return Math.sin(phase * Math.PI);
		},

		wrapperFunctions: {
			'constant': constantWrapper,
			'linear': linearWrapper,
			'half_sinus': halfSinusWrapper
		},
		baseWaveform: sinus,
		wrapperFunction: wrapperFunctions.half_sinus,

		resonantPhase: 0,

        requestSoundData: function (soundData) {
            if (!frequency.value) { 
                return; // no sound selected
            }

            for (var i = 0, size = soundData.length; i < size; i++) {
                //			 resonantPhaseFactor = envelope(noteOnTime, noteOffTime);
                soundData[i] = baseWaveform(phaseDistort(resonantPhase)) * wrapperFunction(phase);
                phase += phase_increment;
                /*
                if (resonantPhaseFactor <= 0) {
                    resonantPhaseFactor = 0.00000001;
                }
                */
                resonantPhase += phase_increment / resonantPhaseFactor.value; 
                while (phase > 1) {
                    phase -= 1;
                    resonantPhase = 0;
                }
            }        
        },
        pdData: new ControlledValue([[0,0], [1,1]]);
};     

  </script>
  <script type="text/javascript" src="waveformPlotter.js"></script>
  <script type="text/javascript" src="Controller.js"></script>
  <script type="text/javascript" src="EnvelopeController.js"></script>
  <script type="text/javascript" src="RibbonController.js"></script>
  <script type="text/javascript" src="keyboardController.js"></script>
  <script type="text/javascript" src="envelope.js"></script>
  <script type="text/javascript" src="audio.js"></script>
  </body>
</html>
